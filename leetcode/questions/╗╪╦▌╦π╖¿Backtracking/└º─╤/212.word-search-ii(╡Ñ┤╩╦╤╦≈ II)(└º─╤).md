<html>
 <body>
  <p>
   给定一个二维网格
   <strong>
    board
   </strong>
   和一个字典中的单词列表
   <strong>
    words
   </strong>
   ，找出所有同时在二维网格和字典中出现的单词。
  </p>
  <p>
   单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
  </p>
  <p>
   <strong>
    示例:
   </strong>
  </p>
  <pre><strong>输入:</strong> 
<strong>words</strong> = <code>["oath","pea","eat","rain"]</code> and <strong>board </strong>=
[
  ['<strong>o</strong>','<strong>a</strong>','a','n'],
  ['e','<strong>t</strong>','<strong>a</strong>','<strong>e</strong>'],
  ['i','<strong>h</strong>','k','r'],
  ['i','f','l','v']
]

<strong>输出: </strong><code>["eat","oath"]</code></pre>
  <p>
   <strong>
    说明:
   </strong>
   <br/>
   你可以假设所有输入都由小写字母
   <code>
    a-z
   </code>
   组成。
  </p>
  <p>
   <strong>
    提示:
   </strong>
  </p>
  <ul>
   <li>
    你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
   </li>
   <li>
    如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题：
    <a href="/problems/implement-trie-prefix-tree/description/">
     实现Trie（前缀树）
    </a>
    。
   </li>
  </ul>
 </body>
</html>